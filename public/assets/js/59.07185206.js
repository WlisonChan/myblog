(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{717:function(v,_,t){"use strict";t.r(_);var n=t(2),p=Object(n.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h4",{attrs:{id:"高并发架构方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高并发架构方案"}},[v._v("#")]),v._v(" 高并发架构方案")]),v._v(" "),t("p",[t("strong",[v._v("网络拥堵：")]),v._v(" 网络拥堵主要是由于请求过多导致的网络带宽被占满，网络带宽被占满后后面的请求无法发送到服务器，而造成网站反应慢。")]),v._v(" "),t("p",[v._v("1、重复的请求（按钮控制）")]),v._v(" "),t("p",[v._v("2、机器人请求（验证码）")]),v._v(" "),t("p",[v._v("3、大量静态资源的请求（动静分离）")]),v._v(" "),t("p",[v._v("4、读多写少（缓存）")]),v._v(" "),t("p",[t("strong",[v._v("应用服务器和数据库：")]),v._v(" 每个应用服务器所能承受的并发数量有限，超负荷运转很容易造成应用服务、数据库崩溃，造成网站不可用的情况。")]),v._v(" "),t("p",[t("strong",[v._v("1、加集群")])]),v._v(" "),t("p",[v._v("对于这种情况我们通常都采用分流的方案，用加应用服务器的方法把请求分流到个多个应用服务器、保证每个服务器所承受的请求在能接受的范围之内。")]),v._v(" "),t("p",[t("strong",[v._v("2、拆分服务")])]),v._v(" "),t("p",[v._v("根据业务的场景进行服务拆分，达到一定的分流效果、针对专门的服务更利于专项的扩展。")]),v._v(" "),t("p",[t("strong",[v._v("3、限流")])]),v._v(" "),t("p",[v._v("提前估算自己所能接受的并发上限，超过此上限的请求直接丢弃或者导流到其他地方已达到限流效果、限流可以在代理(nginx)和应用(redis)中配置对应的策略，常见的限流算法有满桶算法、漏桶算法。")]),v._v(" "),t("p",[t("strong",[v._v("4、分布式锁")])]),v._v(" "),t("p",[v._v("让多个资源请求并发变成串行的队列，把业务操作原子化，后一个请求必须等待前一个请求处理完之后才能处理，有序处理请求解决资源竞争问题。")]),v._v(" "),t("p",[t("strong",[v._v("总体架构节点如下")])]),v._v(" "),t("p",[v._v("1、客户端： 按钮防重复点击、验证码防机器人")]),v._v(" "),t("p",[v._v("2、网络层：CDN缓存静态资源")]),v._v(" "),t("p",[v._v("3、负载层：Nginx ：动静分离、限流、负载均衡")]),v._v(" "),t("p",[v._v("4、应用层：缓存、限流、分布式锁")]),v._v(" "),t("p",[v._v("5、数据层：数据库乐观锁和数据库本身事务锁")])])}),[],!1,null,null,null);_.default=p.exports}}]);