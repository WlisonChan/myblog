(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{687:function(e,v,_){"use strict";_.r(v);var o=_(2),t=Object(o.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"csrf-攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#csrf-攻击"}},[e._v("#")]),e._v(" CSRF 攻击")]),e._v(" "),_("h3",{attrs:{id:"什么是csrf攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是csrf攻击"}},[e._v("#")]),e._v(" 什么是CSRF攻击")]),e._v(" "),_("p",[e._v("​\t\t"),_("code",[e._v("CSRF（Cross-site request forgery）")]),e._v("也被称为 "),_("code",[e._v("one-click attack")]),e._v("或者 "),_("code",[e._v("session riding")]),e._v("，中文全称是叫跨站请求伪造。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。")]),e._v(" "),_("h3",{attrs:{id:"如何避免"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何避免"}},[e._v("#")]),e._v(" 如何避免：")]),e._v(" "),_("ul",[_("li",[_("ol",[_("li",[e._v("验证"),_("code",[e._v("HTTP Referer")]),e._v("字段")])]),e._v(" "),_("p",[_("code",[e._v("HTTP")]),e._v("头中的"),_("code",[e._v("Referer")]),e._v("字段记录了该"),_("code",[e._v("HTTP")]),e._v("请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 "),_("code",[e._v("CSRF")]),e._v("\n攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证"),_("code",[e._v("Referer")]),e._v("值来防御"),_("code",[e._v("CSRF")]),e._v("攻击。")])]),e._v(" "),_("li",[_("ol",{attrs:{start:"2"}},[_("li",[e._v("使用验证码\n关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御"),_("code",[e._v("CSRF")]),e._v("。但这种方法对用户不太友好。")])])]),e._v(" "),_("li",[_("ol",{attrs:{start:"3"}},[_("li",[e._v("在请求地址中添加"),_("code",[e._v("token")]),e._v("并验证\n"),_("code",[e._v("CSRF")]),e._v(" 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于"),_("code",[e._v("cookie")]),e._v("中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的"),_("code",[e._v("cookie")]),e._v(" 来通过安全验证。要抵御"),_("code",[e._v("CSRF")]),e._v("，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 "),_("code",[e._v("cookie")]),e._v(" 之中。可以在"),_("code",[e._v("HTTP")]),e._v(" 请求中以参数的形式加入一个随机产生的 "),_("code",[e._v("token")]),e._v("，并在服务器端建立一个拦截器来验证这个 "),_("code",[e._v("token")]),e._v("，如果请求中没有"),_("code",[e._v("token")]),e._v("或者 "),_("code",[e._v("token")]),e._v(" 内容不正确，则认为可能是 "),_("code",[e._v("CSRF")]),e._v(" 攻击而拒绝该请求。这种方法要比检查 "),_("code",[e._v("Referer")]),e._v(" 要安全一些，"),_("code",[e._v("token")]),e._v(" 可以在用户登陆后产生并放于"),_("code",[e._v("session")]),e._v("之中，然后在每次请求时把"),_("code",[e._v("token")]),e._v(" 从"),_("code",[e._v("session")]),e._v(" 中拿出，与请求中的"),_("code",[e._v("token")]),e._v(" 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。\n对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 "),_("code",[e._v("http://url?csrftoken=tokenvalue。")]),e._v("\n而对于 POST 请求来说，要在 form 的最后加上 "),_("code",[e._v('<input type="hidden" name="csrftoken" value="tokenvalue"/>')]),e._v("，这样就把token以参数的形式加入请求了。")])])]),e._v(" "),_("li",[_("ol",{attrs:{start:"4"}},[_("li",[e._v("在HTTP 头中自定义属性并验证\n这种方法也是使用 "),_("code",[e._v("token")]),e._v(" 并进行验证，和上一种方法不同的是，这里并不是把 "),_("code",[e._v("token")]),e._v(" 以参数的形式置于 "),_("code",[e._v("HTTP")]),e._v(" 请求之中，而是把它放到 "),_("code",[e._v("HTTP")]),e._v(" 头中自定义的属性里。通过 "),_("code",[e._v("XMLHttpRequest")]),e._v(" 这个类，可以一次性给所有该类请求加上 "),_("code",[e._v("csrftoken")]),e._v(" 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。")])])]),e._v(" "),_("li",[_("ol",{attrs:{start:"5"}},[_("li",[e._v("设置"),_("code",[e._v("sessionId")]),e._v("的"),_("code",[e._v("cookie")]),e._v("为"),_("code",[e._v("HttpOnly")]),e._v("，使客户端无法获取")])])])])])}),[],!1,null,null,null);v.default=t.exports}}]);