(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{751:function(t,v,_){"use strict";_.r(v);var n=_(2),s=Object(n.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h4",{attrs:{id:"linux-常见的进程调度算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#linux-常见的进程调度算法"}},[t._v("#")]),t._v(" linux 常见的进程调度算法")]),t._v(" "),_("p",[t._v("​\t\t"),_("strong",[t._v("先来先服务调度算法")])]),t._v(" "),_("p",[t._v("​\t\t先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的 作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列 的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。\n​\t\t**短作业(进程)优先调度算法 **")]),t._v(" "),_("p",[t._v("​\t\t短作业(进程)优 先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择 一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分 配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("高优先权优先调度算法")]),t._v(" "),_("p",[t._v("**优先权调度算法的类型 **")])])]),t._v(" "),_("p",[t._v("​\t\t为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。\n​\t\t**非抢占式优先权算法 **")]),t._v(" "),_("p",[t._v("​\t\t在这种方式 下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重 新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。\n"),_("strong",[t._v("抢占式优先权调度算法")])]),t._v(" "),_("p",[t._v("​\t\t在这种方式 下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原 优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi>Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("基于时间片的轮转调度算法")]),t._v(" "),_("p",[t._v("**时间片轮转法 **")]),t._v(" "),_("p",[t._v("在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机 分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言 之，系统能在给定的时间内响应所有用户的请求。")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);