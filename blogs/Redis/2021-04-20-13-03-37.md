---
title: 简单动态字符串
date: 2021-04-20 13:03:37
sticky: true
tags:

- REDIS
- 数据结构

categories:

- REDIS

isShowComments: true
---

#### 简单动态字符串（Simple Dynamic String）

**使用地方：redis的key、字符串。**

```c++
	struct sdshdr{
        //记录buf数组中已使用字节的数量
        //等于SDS所保存字符串的长度
        int len;
        //记录buf数组中未使用字节的数量
        int free;
        //字节数组，用于保存字符串
        char buf[];
    }
```

<img src="https://markdown-1301775995.cos.ap-nanjing.myqcloud.com/image-20210319003644973.png" alt="image-20210319003644973" style="zoom:50%;" />

- free属性的值为3，表示这个SDS未使用的空间为3字节。
- len属性的值为4，表示这个SDS保存了一个4字节长的字符串。
- buf属性是一个char类型的数组，数组的前4个字节分别保存了4个字符，而最后一个字符则保存了空字符'\0'。

与C字符串相比（后面详细介绍）：

- - 获取一个SDS长度的复杂度仅为O（1）.
- 杜绝了缓冲区溢出。（C++使用strcat()函数前未分配足够内存会溢出）
- 二进制安全。（使用len属性的值而不是空字符来判断字符串是否结束）。
- 修改字符串长度N次最多需要执行N次内存重分配（把长度缩短后只修改len和free即可）
- 兼容部分C字符串函数。

##### 杜绝缓冲区溢出

​		假设一种场景：内存中紧邻着两个C字符串S1和S2，当执行strcat(S1,"william")时，由于S1分配的空间不够，S1的数据将溢出到S2所在的空间，导致S2保存的内容被意外的修改。

<img src="https://markdown-1301775995.cos.ap-nanjing.myqcloud.com/image-20210319011833554.png" alt="image-20210319011833554" style="zoom:50%;" />

​		SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能。当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足，API会自动将SDS的空间扩展至执行修改所需的大小(具体可看下面的空间预分配)，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题。

##### 空间预分配

条件：当对SDS进行修改并且需要进行空间扩展时。

- 1、SDS的长度（`len`属性）小于`1MB`，那么程序分配和len属性同样大小的未使用空间，即`len`属性的值和`free`属性的值相同。
    - 例：对SDS修改后，SDS的len变成13字节，那么程序也会分配13字节的未使用空间。

- 2、SDS的长度大于等于`1MB`，程序会分配`1MB`的未使用空间。
    - 例：对SDS修改后，SDS的len变成`30MB`，那么程序会分配`1MB`的未使用空间，SDS的`buf`数组实际长度将为`30MB+1MB+1byte`。（1byte为空字符）

通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的`内存重分配`次数。

##### 惰性空间释放

惰性空间释放用于优化SDS的字符串缩短操作。

​		当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量纪录起来，并等待将来使用。

​		SDS提供了相应的API，让我们可以在有需要时，真正地释放SDS的未使用空间，所以不需担心惰性空间释放策略会造成的内存浪费。

##### 二进制安全

​		所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。

​		对于保存特殊数据格式也是没有任何问题的，因为SDS使用len属性的值而不是空字符来判断字符串是否结束。
