{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{738:function(a,e,l){\"use strict\";l.r(e);var r=l(2),t=Object(r.a)({},(function(){var a=this,e=a.$createElement,l=a._self._c||e;return l(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[l(\"h4\",{attrs:{id:\"threadlocal\"}},[l(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocal\"}},[a._v(\"#\")]),a._v(\" ThreadLocal\")]),a._v(\" \"),l(\"p\",[a._v(\"ThreadLocal是一个本地线程副本变量的工具类，主要用于将线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰。\")]),a._v(\" \"),l(\"ul\",[l(\"li\",[a._v(\"每个Thread线程内部都有一个Map。\")]),a._v(\" \"),l(\"li\",[a._v(\"Map里面存储线程本地对象（key）和线程的变量副本（value）\")]),a._v(\" \"),l(\"li\",[a._v(\"但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。\")])]),a._v(\" \"),l(\"p\",[a._v(\"**ThreadLocalMap解决hash冲突的方法：步长加1或减1，寻找下一个相邻的位置。 **\")]),a._v(\" \"),l(\"p\",[l(\"strong\",[a._v(\"带来的问题：\")]),a._v(\" 由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。\")]),a._v(\" \"),l(\"p\",[a._v(\"**项目使用：**存储用户的登录信息：创建一个HostHolder组件，并在组件里自定义一个ThreadLocal变量，专门存储用户的信息，在用户每次的请求中通过拦截器来获取用户的信息，然后通过ThreadLocal的set方法将用户信息存储，使得在controller请求中可以携带用户信息，并在拦截器的afterCompletion方法中通过ThreadLocal的remove方法清除value，防止内存泄露。\")])])}),[],!1,null,null,null);e.default=t.exports}}]);","extractedComments":[]}