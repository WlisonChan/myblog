{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{728:function(s,e,a){\"use strict\";a.r(e);var t=a(2),h=Object(t.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[a(\"h4\",{attrs:{id:\"hashcode-和equals\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hashcode-和equals\"}},[s._v(\"#\")]),s._v(\" hashCode()和equals()\")]),s._v(\" \"),a(\"p\",[a(\"strong\",[s._v(\"作用：\")]),s._v(\" 对比两个对象是否相等一致。\")]),s._v(\" \"),a(\"p\",[a(\"strong\",[s._v(\"equals的作用：\")]),s._v(\" 重写equals里一般比较全面和复杂，所以效率较低，而hashCode()虽然性能好，不同对象生成的hashCode有可能会一样，并非绝对可靠。\")]),s._v(\" \"),a(\"ul\",[a(\"li\",[s._v(\"equals()相等的两个对象他们的hashCode()肯定相等。\")]),s._v(\" \"),a(\"li\",[s._v(\"hashCode()相等的两个对象他们的equals()不一定相等。\")])]),s._v(\" \"),a(\"p\",[a(\"strong\",[s._v(\"什么情况下需要重写：\")]),s._v(\" 只有当类需要放在HashTable、Set、HashSet等等集合时才会重写。（如果重写了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样，所以重写equals一般都要重写hashcode。）\")])])}),[],!1,null,null,null);e.default=h.exports}}]);","extractedComments":[]}