{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{726:function(t,e,n){\"use strict\";n.r(e);var a=n(2),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[n(\"h4\",{attrs:{id:\"concurrenthashmap\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#concurrenthashmap\"}},[t._v(\"#\")]),t._v(\" \"),n(\"strong\",[t._v(\"ConcurrentHashMap：\")])]),t._v(\" \"),n(\"h5\",{attrs:{id:\"jdk7\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jdk7\"}},[t._v(\"#\")]),t._v(\" JDK7\")]),t._v(\" \"),n(\"p\",[n(\"strong\",[t._v(\"数据结构：\")]),t._v(\" ReentrantLock+Segment+HashEntry （每个Segment中包含一个HashEntry数组，每个HashEntry是一个链表）\")]),t._v(\" \"),n(\"p\",[n(\"strong\",[t._v(\"元素查询：\")]),t._v(\" 两次hash，第一次hash确定所在的Segment，第二次hash找到元素所在的链表头部。\")]),t._v(\" \"),n(\"p\",[n(\"strong\",[t._v(\"并发分析：\")]),t._v(\" Segment继承了ReentrantLock，并发度为Segment的个数，锁定一个Segment时，其他Segment不受影响\")]),t._v(\" \"),n(\"h5\",{attrs:{id:\"jdk8\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jdk8\"}},[t._v(\"#\")]),t._v(\" JDK8\")]),t._v(\" \"),n(\"p\",[n(\"strong\",[t._v(\"数据结构：\")]),t._v(\" 数组+链表+红黑树+synchronized+CAS\")]),t._v(\" \"),n(\"p\",[n(\"strong\",[t._v(\"并发分析：\")]),t._v(\" 锁定链表的头节点，其他非此链表的元素不受影响，粒度更细，效率更高，扩容时会阻塞所有的读写操作且并发扩容。读取操作不加锁，Node的val和next都使用volatile修饰，读写线程对该变量可见\")])])}),[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}